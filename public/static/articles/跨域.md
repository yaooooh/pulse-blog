根据在 HTTP 请求中，是否会触发 `CORS` 预检请求，分为简单请求和复杂请求

## 简单请求

1. 请求头为 GET、POST、DELETE
2. 请求字段仅限如下
    1. Accept
    2. Accept-Language
    3. Content-Language
    4. Content-Type 值仅限如下
        1. `text/plain`
        2. `multipart/form-data`
        3. `application/x-www-form-urlencoded`
3. 请求中没有使用 `XMLHTTPRequestUpload` 对象，也没有注册任何监听事件
4. 请求中没有使用 `ReadableStream` 对象

## 复杂请求

不满足简单请求条件的请求，通常会触发 `CORS` 预检请求

1. 使用了 PUT、DELETE 方法
2. Content-Type 的值不在上述三种范围内
3. 使用了自定义的请求头

## 预检请求

预检请求是浏览器发送复杂请求前，使用 OPTIONS 方法发起的请求，以确认服务器是否允许实际请求

## 跨域设置 `CORS`

在服务端设置响应头：

```jsx
response.setHeader('Access-Control-Allow-Origin', 'http://localhost:9000')
response.setHeader('Access-Control-Allow-Methods', 'GET')
response.setHeader('Access-Control-Allow-Headers', 'X-Custom-Header')
response.setHeader('Access-Control-Allow-Max-Age', 3600)
```

## 跨域设置 - 反向代理

```jsx
server {
    listen       80;
    listen  [::]:80;
    server_name  localhost;

    # redirect server error pages to the static page /50x.html
    #
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }

    location /api/ {
        proxy_pass  http://host.docker.internal:8000/;
    }

    location / {
        proxy_pass  http://host.docker.internal:9000/;
    }
}
```

### 基本路径匹配类型

1. **前缀匹配 (`location /`)**：
    - 最常见的匹配类型。
    - 匹配以指定路径开头的所有请求。
2. **精确匹配 (`location =`)**：
    - 用于精确匹配特定路径。
    - 如果请求路径与配置的路径完全相同，则会使用此配置。
3. **正则表达式匹配 (`location ~` 和 `location ~*`)**：
    - 使用正则表达式进行匹配。
    - `~` 表示区分大小写的匹配。
    - `~*` 表示不区分大小写的匹配。
4. **优先级排序**：
    - 按照精确匹配、长字符串前缀匹配、正则表达式匹配、通配符后缀匹配和通配符前缀匹配的顺序进行匹配。

### 匹配规则和优先级

`Nginx` 的路径匹配遵循一套严格的优先级规则。基本上，`Nginx` 会根据以下步骤来选择最合适的 `location` 块：

1. **精确匹配 (`=`)**：如果路径完全匹配，`Nginx` 将立即使用这个配置块。
2. **长字符串前缀匹配**：在没有精确匹配时，`Nginx` 会查找最长的前缀匹配。这种匹配不考虑特殊字符，不带任何修饰符（如 `^~`, `~`, `=`）。
3. **正则表达式匹配 (`~` 或 `~*`)**：如果仍未找到匹配，`Nginx` 会尝试匹配正则表达式。如果多个正则表达式匹配，以第一个匹配到的为准。
4. **通配符后缀匹配 (`^~`)**：它用于阻止正则表达式匹配，当找到这种匹配时，不再继续寻找正则表达式匹配。
5. **默认匹配 (`/`)**：如果没有其他匹配项，`Nginx` 将使用这个最通用的匹配。

## 跨域设置 - `JSONP`

当使用 script 标签，其对应 `src` 指向服务端地址时，服务端返回给客户端对应 `js` 代码将会立即被执行。该方式只支持 GET 方式请求，容易遭到恶意攻击。

服务端设置

```jsx
app.get('/jsonp', (request, response) => {
  console.log(request.query)
  // 此时将会执行 callback 函数，并将数据传入到该函数
  response.send(`${request.query.callback}('hello, jsonp data')`)
  // 当服务端返回对应 js 代码时，浏览器会自动执行
  // 如下将会输出 123
  // response.send(`console.log('123')`)
})
```

客户端设置

```jsx
function jsonp(request) {
  const script = document.createElement('script')
  script.src = `${request.url}?callback=${request.callback.name}`
  document.querySelector('head').appendChild(script)
}

function callback (res) {
  console.log(res)
}

jsonp({ url: 'http://localhost/api/jsonp', callback: callback })
```